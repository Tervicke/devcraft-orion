package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/confluentinc/confluent-kafka-go/v2/kafka"
	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	_ "github.com/go-sql-driver/mysql"
	"github.com/joho/godotenv"
)

func setupDb() (*sql.DB, error) {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
		return nil , err;
	}
	dsn := os.Getenv("DB_DSN");
	fmt.Println(dsn);
	db , err := sql.Open("mysql", dsn);
	if err != nil {
		return nil , err;
	}
	db.SetMaxOpenConns(25)
	db.SetMaxIdleConns(10)
	db.SetConnMaxLifetime(time.Hour)
	ctx , cancel := context.WithTimeout(context.Background(), 5*time.Second);
	defer cancel();
	if err := db.PingContext(ctx); err != nil {
		return nil , err;
	}
	return db , nil;
}

type BidRequest struct {
	Bidid string `json:"Bidid"` //gonna be generated by the system
	Auctionid string `json:"Auctionid" binding:"required"` //mandatory
	Userid string `json:"Userid" binding:"required"` //mandatory
	Price float64 `json:"Price" binding:"required"` //mandatory
	Timestamp int64 `json:"Timestamp"` //gonna be generated by the system
}

func bidHandler(c *gin.Context , db *sql.DB , p *kafka.Producer) {
	var req BidRequest;

	//check if the request body is valid
	if err := c.ShouldBindBodyWithJSON(&req); err != nil {
		c.JSON(400, gin.H{"error body did not match": err.Error()});
		return 
	}

	//generate bidid and timestamp
	req.Bidid = "bid-" + fmt.Sprint(req.Userid) + "-" + fmt.Sprint(req.Auctionid);
	req.Timestamp = time.Now().Unix();
	req.Bidid = "123456789"; //for testing purposes only, should be generated by the system
	fmt.Println("Received bid request: \n", req);
	//update the database with the new bid
	res , err := db.Exec(
		"update bids set price = ? where auction_id = ? and ? > price", req.Price, req.Auctionid, req.Price,
	);
	if err != nil {
		log.Println("Failed to update bid: ", err);
		c.JSON(500, gin.H{"error": "Failed to update bid"});
		return;
	}
	rows , _ := res.RowsAffected();

	if rows == 0 {
		log.Println("Bid was not high enough to update the current bid");
		c.JSON(400, gin.H{"error": "Bid was not high enough to update the current bid"});
		return;
	}
	
	msgbytes , err := json.Marshal(req);
	if err != nil {
		log.Println("Failed to marshal bid request: ", err)	
		c.JSON(500, gin.H{"error": "Failed to marshal bid request"});
	}

	topic := "bids";

	p.Produce(
		&kafka.Message{
			TopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},
			Value: msgbytes,
		}, nil,
	)

	c.JSON(200 , gin.H{
		"success":"1",
	});

}
func setupKafkaProducer() (*kafka.Producer, error) {
	p , err := kafka.NewProducer(&kafka.ConfigMap{"bootstrap.servers": "localhost:9092"})
	if err != nil {
		return nil , err;
	}
	go func() {
		for e := range p.Events() {
			switch ev := e.(type) {
			case *kafka.Message:
				if ev.TopicPartition.Error != nil {
					fmt.Println("Delivery failed:", ev.TopicPartition)
				} else {
					fmt.Println("Delivered to", ev.TopicPartition)
				}
			}
		}
	}()
	return p , nil;
}

func main(){
	db , err := setupDb()
	if err != nil {
		fmt.Println("Failed to connect to database: ", err);
		panic(err);
	}

	log.Println("Successfully connected to database");

	//set up the kafka producer
	p , err := setupKafkaProducer();
	if err != nil {
		fmt.Println("Failed to set up Kafka producer: ", err);
		panic(err);
	}
	defer p.Close();

	r := gin.Default();
	r.Use(cors.Default()) // using cors because preflight request needs it
	
	r.GET("/ping", func(c *gin.Context) {
		c.JSON(200, "helloworld");
	});
	
	r.POST("/bid", func(c *gin.Context) {
		bidHandler(c,db,p);
	});

	r.Run(":8080");
}
