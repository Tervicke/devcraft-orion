package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/confluentinc/confluent-kafka-go/v2/kafka"
	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	_ "github.com/go-sql-driver/mysql"
	"github.com/gorilla/websocket"
	"github.com/joho/godotenv"
	"golang.org/x/crypto/bcrypt"
)

func setupDb() (*sql.DB, error) {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
		return nil , err;
	}
	dsn := os.Getenv("DB_DSN");
	fmt.Println(dsn);
	db , err := sql.Open("mysql", dsn);
	if err != nil {
		return nil , err;
	}
	db.SetMaxOpenConns(25)
	db.SetMaxIdleConns(10)
	db.SetConnMaxLifetime(time.Hour)
	ctx , cancel := context.WithTimeout(context.Background(), 5*time.Second);
	defer cancel();
	if err := db.PingContext(ctx); err != nil {
		return nil , err;
	}
	return db , nil;
}

type BidRequest struct {
	Bidid string `json:"Bidid"` //gonna be generated by the system
	Auctionid string `json:"Auctionid" binding:"required"` //mandatory
	Userid string `json:"Userid" binding:"required"` //mandatory
	Price float64 `json:"Price" binding:"required"` //mandatory
	Timestamp int64 `json:"Timestamp"` //gonna be generated by the system
}

type Session struct {
	UserID int64
}

var (
	authDB  *sql.DB
	sessions = make(map[string]Session)
)

func bidHandler(c *gin.Context , db *sql.DB , p *kafka.Producer) {
	var req BidRequest;

	//check if the request body is valid
	if err := c.ShouldBindBodyWithJSON(&req); err != nil {
		c.JSON(400, gin.H{"error body did not match": err.Error()});
		return 
	}

	//generate bidid and timestamp
	req.Bidid = "bid-" + fmt.Sprint(req.Userid) + "-" + fmt.Sprint(req.Auctionid);
	req.Timestamp = time.Now().Unix();
	req.Bidid = "123456789"; //for testing purposes only, should be generated by the system
	fmt.Println("Received bid request: \n", req);
	//update the database with the new bid
	res , err := db.Exec(
		"update bids set price = ? where auction_id = ? and ? > price", req.Price, req.Auctionid, req.Price,
	);
	if err != nil {
		log.Println("Failed to update bid: ", err);
		c.JSON(500, gin.H{"error": "Failed to update bid"});
		return;
	}
	rows , _ := res.RowsAffected();

	if rows == 0 {
		log.Println("Bid was not high enough to update the current bid");
		c.JSON(400, gin.H{"error": "Bid was not high enough to update the current bid"});
		return;
	}
	
	msgbytes , err := json.Marshal(req);
	if err != nil {
		log.Println("Failed to marshal bid request: ", err)	
		c.JSON(500, gin.H{"error": "Failed to marshal bid request"});
	}

	topic := "bids";

	p.Produce(
		&kafka.Message{
			TopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},
			Value: msgbytes,
		}, nil,
	)

	c.JSON(200 , gin.H{
		"success":"1",
	});

}
func setupKafkaProducer() (*kafka.Producer, error) {
	p , err := kafka.NewProducer(&kafka.ConfigMap{"bootstrap.servers": "localhost:9092"})
	if err != nil {
		return nil , err;
	}
	go func() {
		for e := range p.Events() {
			switch ev := e.(type) {
			case *kafka.Message:
				if ev.TopicPartition.Error != nil {
					fmt.Println("Delivery failed:", ev.TopicPartition)
				} else {
					fmt.Println("Delivered to", ev.TopicPartition)
				}
			}
		}
	}()
	return p , nil;
}

func getEnv(key, def string) string {
	if v := os.Getenv(key); v != "" {
		return v
	}
	return def
}

func frontendOrigin() string {
	return getEnv("FRONTEND_ORIGIN", "http://localhost:5173")
}

// corsMiddleware replicates the Bun CORS behavior for auth/auction routes.
func corsMiddleware() gin.HandlerFunc {
	origin := frontendOrigin()
	return func(c *gin.Context) {
		h := c.Writer.Header()
		h.Set("Access-Control-Allow-Origin", origin)
		h.Set("Access-Control-Allow-Credentials", "true")
		h.Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With")
		h.Set("Access-Control-Allow-Methods", "GET,POST,OPTIONS")

		if c.Request.Method == http.MethodOptions {
			c.Status(http.StatusNoContent)
			c.Abort()
			return
		}

		c.Next()
	}
}

func parseSessionCookie(c *gin.Context) *Session {
	cookie, err := c.Request.Cookie("session")
	if err != nil || cookie.Value == "" {
		return nil
	}
	if s, ok := sessions[cookie.Value]; ok {
		return &s
	}
	return nil
}

func createSession(userID int64) string {
	token := strconv.FormatInt(time.Now().UnixNano(), 36) + "-" + strconv.FormatInt(userID, 36)
	sessions[token] = Session{UserID: userID}
	return token
}

func setSessionCookie(c *gin.Context, token string) {
	http.SetCookie(c.Writer, &http.Cookie{
		Name:     "session",
		Value:    token,
		Path:     "/",
		HttpOnly: true,
		SameSite: http.SameSiteLaxMode,
	})
}

func requireSession(c *gin.Context) *Session {
	s := parseSessionCookie(c)
	if s == nil {
		c.JSON(401, gin.H{"error": "Unauthorized"})
		return nil
	}
	return s
}

func handleRegister(c *gin.Context) {
	var body struct {
		Email    string `json:"email"`
		Password string `json:"password"`
	}
	if err := c.ShouldBindJSON(&body); err != nil || body.Email == "" || body.Password == "" {
		c.JSON(400, gin.H{"error": "Email and password are required"})
		return
	}

	var existingID int64
	err := authDB.QueryRow("SELECT id FROM users WHERE email = ? LIMIT 1", body.Email).Scan(&existingID)
	if err != nil && err != sql.ErrNoRows {
		log.Printf("error checking existing user: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}
	if err == nil {
		c.JSON(409, gin.H{"error": "User with this email already exists"})
		return
	}

	passwordHash, err := bcrypt.GenerateFromPassword([]byte(body.Password), 10)
	if err != nil {
		log.Printf("error hashing password: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	res, err := authDB.Exec("INSERT INTO users (email, password_hash) VALUES (?, ?)", body.Email, string(passwordHash))
	if err != nil {
		log.Printf("error inserting user: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	userID, err := res.LastInsertId()
	if err != nil {
		log.Printf("error getting insert id: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	token := createSession(userID)
	setSessionCookie(c, token)
	c.JSON(201, gin.H{"id": userID, "email": body.Email})
}

func handleLogin(c *gin.Context) {
	var body struct {
		Email    string `json:"email"`
		Password string `json:"password"`
	}
	if err := c.ShouldBindJSON(&body); err != nil || body.Email == "" || body.Password == "" {
		c.JSON(400, gin.H{"error": "Email and password are required"})
		return
	}

	var (
		userID       int64
		passwordHash string
	)
	err := authDB.QueryRow("SELECT id, password_hash FROM users WHERE email = ? LIMIT 1", body.Email).Scan(&userID, &passwordHash)
	if err == sql.ErrNoRows {
		c.JSON(401, gin.H{"error": "Invalid email or password"})
		return
	}
	if err != nil {
		log.Printf("error selecting user: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	if err := bcrypt.CompareHashAndPassword([]byte(passwordHash), []byte(body.Password)); err != nil {
		c.JSON(401, gin.H{"error": "Invalid email or password"})
		return
	}

	token := createSession(userID)
	setSessionCookie(c, token)
	c.JSON(200, gin.H{"id": userID, "email": body.Email})
}

func handleDashboard(c *gin.Context) {
	s := requireSession(c)
	if s == nil {
		return
	}
	c.JSON(200, gin.H{
		"message": "Dashboard data placeholder",
		"userId":  s.UserID,
	})
}

func handleCreateAuction(c *gin.Context) {
	s := requireSession(c)
	if s == nil {
		return
	}

	var body struct {
		Item          string   `json:"item"`
		StartingPrice *float64 `json:"startingPrice"`
		Image         *string  `json:"image"`
		EndTime       string   `json:"endTime"`
	}
	if err := c.ShouldBindJSON(&body); err != nil || body.Item == "" || body.StartingPrice == nil || body.EndTime == "" {
		c.JSON(400, gin.H{"error": "Item, starting price, and end time are required"})
		return
	}

	fmt.Println("Received create auction request: \n", body);

	layout := "2006-01-02T15:04"
	endTime, err := time.Parse(layout, body.EndTime)
	if err != nil {
		c.JSON(400, gin.H{"error": "Invalid end time"})
		return
	}

	var image interface{}
	if body.Image != nil && *body.Image != "" {
		image = *body.Image
	} else {
		image = nil
	}

	//use a transaction to ensure both auction and initial bid are created together
	tx, err := authDB.Begin()
	if err != nil {
		log.Printf("error starting transaction: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	res, err := tx.Exec(
		"INSERT INTO auctions (user_id, item, starting_price, image_url, end_time) VALUES (?, ?, ?, ?, ?)",
		s.UserID, body.Item, *body.StartingPrice, image, endTime,
	)
	if err != nil {
		tx.Rollback()
		log.Printf("error inserting auction: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	auctionID, err := res.LastInsertId()
	if err != nil {
		tx.Rollback()
		log.Printf("error getting auction insert id: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	_, err = tx.Exec(
		"INSERT INTO bids (auction_id, user_id, price) VALUES (?, ?, ?)",
		auctionID,
		s.UserID,
		*body.StartingPrice,
	)
	if err != nil {
		tx.Rollback()
		log.Printf("error inserting initial bid: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	if err := tx.Commit(); err != nil {
		log.Printf("error committing transaction: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	c.JSON(201, gin.H{"auctionId": auctionID})
}

func handleGetAuction(c *gin.Context) {
	id := c.Param("id")

	var (
		auctionID     int64
		item          string
		startingPrice float64
		currentPrice  float64
		imageURL      sql.NullString
		endTime       time.Time
	)

	err := authDB.QueryRow(
		`SELECT a.id, a.item, a.starting_price,
		 COALESCE((SELECT MAX(b.price) FROM bids b WHERE b.auction_id = a.id), a.starting_price),
		 a.image_url, a.end_time
		 FROM auctions a WHERE a.id = ?`,
		id,
	).Scan(&auctionID, &item, &startingPrice, &currentPrice, &imageURL, &endTime)
	if err == sql.ErrNoRows {
		c.JSON(404, gin.H{"error": "Auction not found"})
		return
	}
	if err != nil {
		log.Printf("error selecting auction: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	var img *string
	if imageURL.Valid {
		img = &imageURL.String
	}

	c.JSON(200, gin.H{
		"id":            auctionID,
		"item":          item,
		"startingPrice": startingPrice,
		"currentPrice":  currentPrice,
		"imageUrl":      img,
		"endTime":       endTime.UTC().Format(time.RFC3339),
	})
}

var upgrader = websocket.Upgrader{
	CheckOrigin: func(r *http.Request) bool {
		// CORS is already handled via headers, allow all origins here;
		// Gin CORS middleware ensures correct headers.
		return true
	},
}

func handleAuctionWebsocket(c *gin.Context) {
	// Path is /auction/:id, mirror Bun behavior checking prefix
	if !strings.HasPrefix(c.Request.URL.Path, "/auction/") {
		c.String(404, "Not Found")
		return
	}

	s := requireSession(c)
	if s == nil {
		return
	}

	auctionID := c.Param("id")

	conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
	if err != nil {
		log.Printf("websocket upgrade failed: %v", err)
		return
	}
	defer conn.Close()

	log.Printf("WebSocket connected for auction %s", auctionID)
	for {
		mt, message, err := conn.ReadMessage()
		if err != nil {
			if !websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway) {
				log.Printf("websocket read error for auction %s: %v", auctionID, err)
			}
			break
		}
		// Echo back same message (placeholder broadcasting).
		if err := conn.WriteMessage(mt, message); err != nil {
			log.Printf("websocket write error for auction %s: %v", auctionID, err)
			break
		}
	}
	log.Printf("WebSocket closed for auction %s", auctionID)
}
func corsAllowAll() gin.HandlerFunc {
	return func(c *gin.Context) {
		origin := frontendOrigin()
		h := c.Writer.Header()
		h.Set("Access-Control-Allow-Origin", origin)
		h.Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With")
		h.Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
		h.Set("Access-Control-Allow-Credentials", "true")

		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(204)
			return
		}

		c.Next()
	}
}
func main(){
	db , err := setupDb()
	if err != nil {
		fmt.Println("Failed to connect to database: ", err);
		panic(err);
	}

	log.Println("Successfully connected to database");

	authDB = db

	//set up the kafka producer
	p , err := setupKafkaProducer();
	if err != nil {
		fmt.Println("Failed to set up Kafka producer: ", err);
		panic(err);
	}
	defer p.Close();

	r := gin.Default();
	//only allow localhost:5173 cors and include allow creditinals
	r.Use(cors.New(cors.Config{
		AllowOrigins:     []string{"http://localhost:5173"},
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
		MaxAge:           12 * time.Hour,
	}))

	
	r.GET("/ping", func(c *gin.Context) {
		c.JSON(200, "helloworld");
	});
	
	r.POST("/bid", func(c *gin.Context) {
		fmt.Println("Received bid request");
		bidHandler(c,db,p);
	});

	r.POST("/register", handleRegister)
	r.POST("/login", handleLogin)
	r.GET("/dashboard", handleDashboard)
	r.POST("/create", handleCreateAuction)
	r.GET("/api/auction/:id", handleGetAuction)
	r.GET("/auction/:id", handleAuctionWebsocket)

	r.Run(":3000");
}
