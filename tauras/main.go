package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/confluentinc/confluent-kafka-go/v2/kafka"
	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	_ "github.com/go-sql-driver/mysql"
	"github.com/gorilla/websocket"
	"github.com/joho/godotenv"
	"golang.org/x/crypto/bcrypt"
)

func setupDb() (*sql.DB, error) {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
		return nil , err;
	}
	dsn := os.Getenv("DB_DSN");
	fmt.Println(dsn);
	db , err := sql.Open("mysql", dsn);
	if err != nil {
		return nil , err;
	}
	db.SetMaxOpenConns(25)
	db.SetMaxIdleConns(10)
	db.SetConnMaxLifetime(time.Hour)
	ctx , cancel := context.WithTimeout(context.Background(), 5*time.Second);
	defer cancel();
	if err := db.PingContext(ctx); err != nil {
		return nil , err;
	}
	return db , nil;
}

type BidRequest struct {
	Bidid string `json:"Bidid"` //gonna be generated by the system
	Auctionid string `json:"Auctionid" binding:"required"` //mandatory
	Userid string `json:"Userid" binding:"required"` //mandatory
	Price float64 `json:"Price" binding:"required"` //mandatory
	Timestamp int64 `json:"Timestamp"` //gonna be generated by the system
}

type Session struct {
	UserID int64
}

var (
	authDB   *sql.DB
	sessions = make(map[string]Session)
)

// auctionHub tracks WebSocket connections per auction for broadcasting new bids.
type auctionHub struct {
	mu    sync.RWMutex
	conns map[string]map[*websocket.Conn]struct{}
}

func (h *auctionHub) register(auctionID string, conn *websocket.Conn) {
	h.mu.Lock()
	defer h.mu.Unlock()
	if h.conns[auctionID] == nil {
		h.conns[auctionID] = make(map[*websocket.Conn]struct{})
	}
	h.conns[auctionID][conn] = struct{}{}
}

func (h *auctionHub) unregister(auctionID string, conn *websocket.Conn) {
	h.mu.Lock()
	defer h.mu.Unlock()
	if m := h.conns[auctionID]; m != nil {
		delete(m, conn)
		if len(m) == 0 {
			delete(h.conns, auctionID)
		}
	}
}

func (h *auctionHub) broadcastBid(auctionID string, payload interface{}) {
	h.mu.RLock()
	conns := make([]*websocket.Conn, 0, len(h.conns[auctionID]))
	for c := range h.conns[auctionID] {
		conns = append(conns, c)
	}
	h.mu.RUnlock()
	for _, conn := range conns {
		if err := conn.WriteJSON(payload); err != nil {
			log.Printf("websocket broadcast write error: %v", err)
			h.unregister(auctionID, conn)
		}
	}
}

var wsHub = &auctionHub{conns: make(map[string]map[*websocket.Conn]struct{})}

func bidHandler(c *gin.Context, db *sql.DB, p *kafka.Producer) {
	s := requireSession(c)
	if s == nil {
		return
	}

	var req BidRequest
	if err := c.ShouldBindBodyWithJSON(&req); err != nil {
		c.JSON(400, gin.H{"error": "body did not match: " + err.Error()})
		return
	}

	req.Bidid = "bid-" + fmt.Sprint(req.Userid) + "-" + fmt.Sprint(req.Auctionid)
	req.Timestamp = time.Now().Unix()
	fmt.Println("Received bid request: \n", req)

	auctionID, err := strconv.ParseInt(req.Auctionid, 10, 64)
	if err != nil {
		c.JSON(400, gin.H{"error": "Invalid auction id"})
		return
	}

	// Enforce auction end time (IST / Asia-Kolkata).
	var endTime time.Time
	if err := db.QueryRow("SELECT end_time FROM auctions WHERE id = ?", auctionID).Scan(&endTime); err != nil {
		if err == sql.ErrNoRows {
			c.JSON(404, gin.H{"error": "Auction not found"})
			return
		}
		log.Printf("error selecting auction end_time: %v", err)
		c.JSON(500, gin.H{"error": "Failed to validate auction end time"})
		return
	}

	loc, locErr := time.LoadLocation("Asia/Kolkata")
	if locErr != nil {
		log.Printf("error loading IST location: %v", locErr)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	nowIST := time.Now().In(loc)
	endIST := endTime.In(loc)
	if !nowIST.Before(endIST) {
		c.JSON(400, gin.H{"error": "Auction has already ended"})
		return
	}

	var maxPrice sql.NullFloat64
	err = db.QueryRow(
		"SELECT COALESCE(MAX(price), 0) FROM bids WHERE auction_id = ?",
		auctionID,
	).Scan(&maxPrice)
	if err != nil {
		log.Printf("error getting max bid: %v", err)
		c.JSON(500, gin.H{"error": "Failed to update bid"})
		return
	}
	currentMax := 0.0
	if maxPrice.Valid {
		currentMax = maxPrice.Float64
	}
	if req.Price <= currentMax {
		c.JSON(400, gin.H{"error": "Bid was not high enough to update the current bid"})
		return
	}

	_, err = db.Exec(
		"INSERT INTO bids (auction_id, user_id, price) VALUES (?, ?, ?)",
		auctionID, s.UserID, req.Price,
	)
	if err != nil {
		log.Printf("error inserting bid: %v", err)
		c.JSON(500, gin.H{"error": "Failed to update bid"})
		return
	}

	var bidderEmail string
	if err := db.QueryRow("SELECT email FROM users WHERE id = ?", s.UserID).Scan(&bidderEmail); err != nil {
		bidderEmail = ""
	}
	wsHub.broadcastBid(req.Auctionid, gin.H{"Price": req.Price, "email": bidderEmail})

	msgbytes, err := json.Marshal(req)
	if err != nil {
		log.Println("Failed to marshal bid request: ", err)
	}
	if p != nil {
		p.Produce(
			&kafka.Message{
				TopicPartition: kafka.TopicPartition{Topic: strPtr("bids"), Partition: kafka.PartitionAny},
				Value:          msgbytes,
			}, nil,
		)
	}

	c.JSON(200, gin.H{"success": "1"})
}

func strPtr(s string) *string { return &s }
func setupKafkaProducer() (*kafka.Producer, error) {
	p , err := kafka.NewProducer(&kafka.ConfigMap{"bootstrap.servers": "localhost:9092"})
	if err != nil {
		return nil , err;
	}
	go func() {
		for e := range p.Events() {
			switch ev := e.(type) {
			case *kafka.Message:
				if ev.TopicPartition.Error != nil {
					fmt.Println("Delivery failed:", ev.TopicPartition)
				} else {
					fmt.Println("Delivered to", ev.TopicPartition)
				}
			}
		}
	}()
	return p , nil;
}

func getEnv(key, def string) string {
	if v := os.Getenv(key); v != "" {
		return v
	}
	return def
}

func frontendOrigin() string {
	return getEnv("FRONTEND_ORIGIN", "http://localhost:5173")
}

// corsMiddleware replicates the Bun CORS behavior for auth/auction routes.
func corsMiddleware() gin.HandlerFunc {
	origin := frontendOrigin()
	return func(c *gin.Context) {
		h := c.Writer.Header()
		h.Set("Access-Control-Allow-Origin", origin)
		h.Set("Access-Control-Allow-Credentials", "true")
		h.Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With")
		h.Set("Access-Control-Allow-Methods", "GET,POST,OPTIONS")

		if c.Request.Method == http.MethodOptions {
			c.Status(http.StatusNoContent)
			c.Abort()
			return
		}

		c.Next()
	}
}

func parseSessionCookie(c *gin.Context) *Session {
	cookie, err := c.Request.Cookie("session")
	if err != nil || cookie.Value == "" {
		return nil
	}
	if s, ok := sessions[cookie.Value]; ok {
		return &s
	}
	return nil
}

func createSession(userID int64) string {
	token := strconv.FormatInt(time.Now().UnixNano(), 36) + "-" + strconv.FormatInt(userID, 36)
	sessions[token] = Session{UserID: userID}
	return token
}

func setSessionCookie(c *gin.Context, token string) {
	http.SetCookie(c.Writer, &http.Cookie{
		Name:     "session",
		Value:    token,
		Path:     "/",
		HttpOnly: true,
		SameSite: http.SameSiteLaxMode,
	})
}

func requireSession(c *gin.Context) *Session {
	if os.Getenv("LOAD_TEST") == "true" {
    return &Session{UserID: -1}
	}
	s := parseSessionCookie(c)
	if s == nil {
		c.JSON(401, gin.H{"error": "Unauthorized"})
		return nil
	}
	return s
}

func handleRegister(c *gin.Context) {
	var body struct {
		Email    string `json:"email"`
		Password string `json:"password"`
	}
	if err := c.ShouldBindJSON(&body); err != nil || body.Email == "" || body.Password == "" {
		c.JSON(400, gin.H{"error": "Email and password are required"})
		return
	}

	var existingID int64
	err := authDB.QueryRow("SELECT id FROM users WHERE email = ? LIMIT 1", body.Email).Scan(&existingID)
	if err != nil && err != sql.ErrNoRows {
		log.Printf("error checking existing user: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}
	if err == nil {
		c.JSON(409, gin.H{"error": "User with this email already exists"})
		return
	}

	passwordHash, err := bcrypt.GenerateFromPassword([]byte(body.Password), 10)
	if err != nil {
		log.Printf("error hashing password: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	res, err := authDB.Exec("INSERT INTO users (email, password_hash) VALUES (?, ?)", body.Email, string(passwordHash))
	if err != nil {
		log.Printf("error inserting user: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	userID, err := res.LastInsertId()
	if err != nil {
		log.Printf("error getting insert id: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	token := createSession(userID)
	setSessionCookie(c, token)
	c.JSON(201, gin.H{"id": userID, "email": body.Email})
}

func handleLogin(c *gin.Context) {
	var body struct {
		Email    string `json:"email"`
		Password string `json:"password"`
	}
	if err := c.ShouldBindJSON(&body); err != nil || body.Email == "" || body.Password == "" {
		c.JSON(400, gin.H{"error": "Email and password are required"})
		return
	}

	var (
		userID       int64
		passwordHash string
	)
	err := authDB.QueryRow("SELECT id, password_hash FROM users WHERE email = ? LIMIT 1", body.Email).Scan(&userID, &passwordHash)
	if err == sql.ErrNoRows {
		c.JSON(401, gin.H{"error": "Invalid email or password"})
		return
	}
	if err != nil {
		log.Printf("error selecting user: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	if err := bcrypt.CompareHashAndPassword([]byte(passwordHash), []byte(body.Password)); err != nil {
		c.JSON(401, gin.H{"error": "Invalid email or password"})
		return
	}

	token := createSession(userID)
	setSessionCookie(c, token)
	c.JSON(200, gin.H{"id": userID, "email": body.Email})
}

func handleDashboard(c *gin.Context) {
	s := requireSession(c)
	if s == nil {
		return
	}
	c.JSON(200, gin.H{
		"message": "Dashboard data placeholder",
		"userId":  s.UserID,
	})
}

func handleCreateAuction(c *gin.Context) {
	s := requireSession(c)
	if s == nil {
		return
	}

	var body struct {
		Item          string   `json:"item"`
		StartingPrice *float64 `json:"startingPrice"`
		Image         *string  `json:"image"`
		EndTime       string   `json:"endTime"`
	}
	if err := c.ShouldBindJSON(&body); err != nil || body.Item == "" || body.StartingPrice == nil || body.EndTime == "" {
		c.JSON(400, gin.H{"error": "Item, starting price, and end time are required"})
		return
	}

	fmt.Println("Received create auction request: \n", body);

	// Treat all end times as IST (Asia/Kolkata) local time.
	loc, err := time.LoadLocation("Asia/Kolkata")
	if err != nil {
		log.Printf("error loading IST location: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	layout := "2006-01-02T15:04"
	endTime, err := time.ParseInLocation(layout, body.EndTime, loc)
	if err != nil {
		c.JSON(400, gin.H{"error": "Invalid end time"})
		return
	}

	var image interface{}
	if body.Image != nil && *body.Image != "" {
		image = *body.Image
	} else {
		image = nil
	}

	//use a transaction to ensure both auction and initial bid are created together
	tx, err := authDB.Begin()
	if err != nil {
		log.Printf("error starting transaction: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	res, err := tx.Exec(
		"INSERT INTO auctions (user_id, item, starting_price, image_url, end_time) VALUES (?, ?, ?, ?, ?)",
		s.UserID, body.Item, *body.StartingPrice, image, endTime,
	)
	if err != nil {
		tx.Rollback()
		log.Printf("error inserting auction: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	auctionID, err := res.LastInsertId()
	if err != nil {
		tx.Rollback()
		log.Printf("error getting auction insert id: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	_, err = tx.Exec(
		"INSERT INTO bids (auction_id, user_id, price) VALUES (?, ?, ?)",
		auctionID,
		s.UserID,
		*body.StartingPrice,
	)
	if err != nil {
		tx.Rollback()
		log.Printf("error inserting initial bid: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	if err := tx.Commit(); err != nil {
		log.Printf("error committing transaction: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	c.JSON(201, gin.H{"auctionId": auctionID})
}

func handleGetAuction(c *gin.Context) {
	id := c.Param("id")

	var (
		auctionID     int64
		item          string
		startingPrice float64
		currentPrice  float64
		imageURL      sql.NullString
		endTime       time.Time
	)

	err := authDB.QueryRow(
		`SELECT a.id, a.item, a.starting_price,
		 COALESCE((SELECT MAX(b.price) FROM bids b WHERE b.auction_id = a.id), a.starting_price),
		 a.image_url, a.end_time
		 FROM auctions a WHERE a.id = ?`,
		id,
	).Scan(&auctionID, &item, &startingPrice, &currentPrice, &imageURL, &endTime)
	if err == sql.ErrNoRows {
		c.JSON(404, gin.H{"error": "Auction not found"})
		return
	}
	if err != nil {
		log.Printf("error selecting auction: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}

	var img *string
	if imageURL.Valid {
		img = &imageURL.String
	}

	c.JSON(200, gin.H{
		"id":            auctionID,
		"item":          item,
		"startingPrice": startingPrice,
		"currentPrice":  currentPrice,
		"imageUrl":      img,
		"endTime":       endTime.UTC().Format(time.RFC3339),
	})
}

func handleGetAuctionBids(c *gin.Context) {
	id := c.Param("id")

	rows, err := authDB.Query(
		`SELECT b.price, u.email FROM bids b
		 JOIN users u ON u.id = b.user_id
		 WHERE b.auction_id = ?
		 ORDER BY b.price DESC
		 LIMIT 20`,
		id,
	)
	if err != nil {
		log.Printf("error selecting bids: %v", err)
		c.JSON(500, gin.H{"error": "Internal server error"})
		return
	}
	defer rows.Close()

	var bids []gin.H
	for rows.Next() {
		var price float64
		var email string
		if err := rows.Scan(&price, &email); err != nil {
			log.Printf("error scanning bid: %v", err)
			continue
		}
		bids = append(bids, gin.H{"price": price, "email": email})
	}
	if bids == nil {
		bids = []gin.H{}
	}

	c.JSON(200, gin.H{"bids": bids})
}

var upgrader = websocket.Upgrader{
	CheckOrigin: func(r *http.Request) bool {
		// CORS is already handled via headers, allow all origins here;
		// Gin CORS middleware ensures correct headers.
		return true
	},
}

func handleAuctionWebsocket(c *gin.Context) {
	// Path is /auction/:id, mirror Bun behavior checking prefix
	if !strings.HasPrefix(c.Request.URL.Path, "/auction/") {
		c.String(404, "Not Found")
		return
	}

	s := requireSession(c)
	if s == nil {
		return
	}

	auctionID := c.Param("id")

	conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
	if err != nil {
		log.Printf("websocket upgrade failed: %v", err)
		return
	}
	defer conn.Close()

	wsHub.register(auctionID, conn)
	defer wsHub.unregister(auctionID, conn)

	log.Printf("WebSocket connected for auction %s", auctionID)
	// Read loop only to keep connection alive and detect client close; no echo.
	for {
		_, _, err := conn.ReadMessage()
		if err != nil {
			if !websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway) {
				log.Printf("websocket read error for auction %s: %v", auctionID, err)
			}
			break
		}
	}
	log.Printf("WebSocket closed for auction %s", auctionID)
}
func corsAllowAll() gin.HandlerFunc {
	return func(c *gin.Context) {
		origin := frontendOrigin()
		h := c.Writer.Header()
		h.Set("Access-Control-Allow-Origin", origin)
		h.Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With")
		h.Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
		h.Set("Access-Control-Allow-Credentials", "true")

		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(204)
			return
		}

		c.Next()
	}
}
func main(){
	db , err := setupDb()
	if err != nil {
		fmt.Println("Failed to connect to database: ", err);
		panic(err);
	}

	log.Println("Successfully connected to database");

	authDB = db

	//set up the kafka producer
	p , err := setupKafkaProducer();
	if err != nil {
		fmt.Println("Failed to set up Kafka producer: ", err);
		panic(err);
	}
	defer p.Close();

	r := gin.Default();
	//only allow localhost:5173 cors and include allow creditinals
	r.Use(cors.New(cors.Config{
		AllowOrigins:     []string{"http://localhost:5173"},
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
		MaxAge:           12 * time.Hour,
	}))

	
	r.GET("/ping", func(c *gin.Context) {
		c.JSON(200, "helloworld");
	});
	
	r.POST("/bid", func(c *gin.Context) {
		fmt.Println("Received bid request");
		bidHandler(c,db,p);
	});

	r.POST("/register", handleRegister)
	r.POST("/login", handleLogin)
	r.GET("/dashboard", handleDashboard)
	r.POST("/create", handleCreateAuction)
	r.GET("/api/auction/:id", handleGetAuction)
	r.GET("/api/auction/:id/bids", handleGetAuctionBids)
	r.GET("/auction/:id", handleAuctionWebsocket)

	r.Run(":3000");
}
