package main

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/gin-gonic/gin"
	_ "github.com/go-sql-driver/mysql"
	"github.com/joho/godotenv"
)

type BidRequest struct {
	Bidid string `json:"Bidid"` //gonna be generated by the system
	Auctionid string `json:"Auctionid" binding:"required"` //mandatory
	Userid string `json:"Userid" binding:"required"` //mandatory
	Price float64 `json:"Price" binding:"required"` //mandatory
	Timestamp int64 `json:"Timestamp"` //gonna be generated by the system
}

func setupDb() (*sql.DB, error) {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
		return nil , err;
	}
	dsn := os.Getenv("DB_DSN");
	fmt.Println(dsn);
	db , err := sql.Open("mysql", dsn);
	if err != nil {
		return nil , err;
	}
	db.SetMaxOpenConns(25)
	db.SetMaxIdleConns(10)
	db.SetConnMaxLifetime(time.Hour)
	ctx , cancel := context.WithTimeout(context.Background(), 5*time.Second);
	defer cancel();
	if err := db.PingContext(ctx); err != nil {
		return nil , err;
	}
	return db , nil;
}
func bidHandler(c *gin.Context , db *sql.DB) {
	var req BidRequest;

	//check if the request body is valid
	if err := c.ShouldBindBodyWithJSON(&req); err != nil {
		c.JSON(400, gin.H{"error body did not match": err.Error()});
		return 
	}

	//generate bidid and timestamp
	req.Bidid = "bid-" + fmt.Sprint(req.Userid) + "-" + fmt.Sprint(req.Auctionid);
	req.Timestamp = time.Now().Unix();
	req.Bidid = "123456789"; //for testing purposes only, should be generated by the system
	fmt.Println("Received bid request: \n", req);
	c.JSON(200 , gin.H{
		"message":"success",
	});
}

func main(){
	db , err := setupDb()
	if err != nil {
		fmt.Println("Failed to connect to database: ", err);
		panic(err);
	}

	log.Println("Successfully connected to database");

	r := gin.Default();
	
	r.GET("/ping", func(c *gin.Context) {
		c.JSON(200, "helloworld");
	});
	
	r.POST("/bid", func(c *gin.Context) {
		bidHandler(c,db);
	});

	r.Run(":8080");
}